<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OMR Capture</title>

  <style>
    :root {
      --w: 340px;
      --red: #ff2d2d;
      --green: #1fbf4c;
      --muted: #555;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }

    #wrap {
      position: relative;
      width: var(--w);
      max-width: 100%;
    }

    #video {
      width: 100%;
      display: block;
      border-radius: 8px;
      background: #000;
    }

    #box {
      position: absolute;
      border: 3px solid var(--red);
      border-radius: 8px;
      pointer-events: none;
      transition: border-color 140ms ease;
    }

    #box.detected {
      border-color: var(--green);
    }

    #status {
      margin-top: 8px;
      min-height: 22px;
      color: var(--muted);
      font-size: 18px;
    }

    #controls {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      padding: 8px 12px;
      border: 1px solid #ccc;
      background: #fff;
      border-radius: 6px;
      cursor: pointer;
    }

    #captureBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .output-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 12px;
      margin-top: 14px;
      max-width: 1000px;
    }

    .output-card {
      font-size: 14px;
      color: #333;
    }

    .output-card img {
      width: 100%;
      max-width: var(--w);
      border: 1px solid #ddd;
      border-radius: 6px;
      display: block;
      margin-top: 6px;
      background: #f7f7f7;
      min-height: 120px;
      object-fit: contain;
    }
  </style>
</head>

<body>

<h3>Place OMR inside frame</h3>

<div id="wrap">
  <video id="video" autoplay playsinline></video>
  <div id="box"></div>
</div>

<div id="status">Searching for document inside red box…</div>

<div id="controls">
  <button id="captureBtn" onclick="capture()" disabled>Capture</button>
  <button onclick="capture(true)">Capture Anyway</button>
</div>

<canvas id="canvas" style="display:none"></canvas>

<div class="output-grid">
  <div class="output-card">
    1) Captured Image (Inside Red Box)
    <img id="capturedResult" />
  </div>

  <div class="output-card">
    2) Edge + CamScanner Final (Before Crop)
    <img id="pipelineResult" />
  </div>

  <div class="output-card">
    3) Cropped Image (Final Output)
    <img id="croppedResult" />
  </div>
</div>

<script>
  const video = document.getElementById("video");
  const wrap = document.getElementById("wrap");
  const box = document.getElementById("box");
  const statusText = document.getElementById("status");
  const captureBtn = document.getElementById("captureBtn");
  const capturedResult = document.getElementById("capturedResult");
  const pipelineResult = document.getElementById("pipelineResult");
  const croppedResult = document.getElementById("croppedResult");
  const canvas = document.getElementById("canvas");

  const OMR_RATIO = 26.5 / 21.5;
  const BOX_WIDTH_RATIO = 0.84;

  let detectBusy = false;

  async function startCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: "environment" } },
        audio: false
      });
      video.srcObject = stream;
    } catch (err) {
      console.error(err);
      statusText.textContent = "Camera access failed.";
    }
  }

  function updateBoundingBox() {
    const w = video.clientWidth;
    const h = video.clientHeight;
    if (!w || !h) return;

    wrap.style.height = `${h}px`;

    const maxW = h / OMR_RATIO;
    const bw = Math.min(w * BOX_WIDTH_RATIO, maxW);
    const bh = bw * OMR_RATIO;

    box.style.width = `${bw}px`;
    box.style.height = `${bh}px`;
    box.style.left = `${(w - bw) / 2}px`;
    box.style.top = `${(h - bh) / 2}px`;
  }

  video.addEventListener("loadedmetadata", () => {
    updateBoundingBox();
    setInterval(updateDetectionState, 180);
  });

  window.addEventListener("resize", updateBoundingBox);

  async function updateDetectionState() {
    if (detectBusy || !video.videoWidth) return;
    detectBusy = true;

    try {
      const ctx = canvas.getContext("2d");
      const scale = Math.min(1, 640 / video.videoWidth);

      canvas.width = video.videoWidth * scale;
      canvas.height = video.videoHeight * scale;
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      const img = canvas.toDataURL("image/jpeg", 0.7);

      const res = await fetch("/detect", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ img })
      });

      if (!res.ok) return;

      const data = await res.json();
      box.classList.toggle("detected", data.detected);
      captureBtn.disabled = !data.can_capture;

      statusText.textContent = data.detected
        ? "Document detected ✓"
        : "Searching for document inside red box…";
    } catch (e) {
      console.error(e);
    } finally {
      detectBusy = false;
    }
  }

  function capture(force = false) {
    if (!force && captureBtn.disabled) return;

    const ctx = canvas.getContext("2d");
    const scale = Math.min(1, 1280 / video.videoWidth);

    canvas.width = video.videoWidth * scale;
    canvas.height = video.videoHeight * scale;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    const img = canvas.toDataURL("image/jpeg", 0.92);

    fetch("/process", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ img })
    })
      .then(r => r.json())
      .then(d => {
        capturedResult.src = d.captured_image || "";
        pipelineResult.src = d.pipeline_image || "";
        croppedResult.src = d.cropped_image || "";
      })
      .catch(console.error);
  }

  startCamera();
</script>

</body>
</html> -->



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>OMR Capture</title>

  <style>
    :root {
      --w: 340px;
      --red: #ff2d2d;
      --green: #1fbf4c;
      --muted: #555;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }

    #wrap {
      position: relative;
      width: var(--w);
      max-width: 100%;
    }

    #video {
      width: 100%;
      display: block;
      border-radius: 8px;
      background: #000;
    }

    #box {
      position: absolute;
      border: 3px solid var(--red);
      border-radius: 8px;
      pointer-events: none;
      transition: border-color 140ms ease;
    }

    #box.detected {
      border-color: var(--green);
    }

    #status {
      margin-top: 8px;
      min-height: 22px;
      color: var(--muted);
      font-size: 18px;
    }

    #controls {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button {
      padding: 8px 12px;
      border: 1px solid #ccc;
      background: #fff;
      border-radius: 6px;
      cursor: pointer;
    }

    #captureBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .output-grid.hidden {
      display: none;
    }

    .output-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 12px;
      margin-top: 14px;
      max-width: 1000px;
    }

    .output-card {
      font-size: 14px;
      color: #333;
    }

    .output-card img {
      width: 100%;
      max-width: var(--w);
      border: 1px solid #ddd;
      border-radius: 6px;
      display: block;
      margin-top: 6px;
      background: #f7f7f7;
      min-height: 120px;
      object-fit: contain;
    }
  </style>
</head>

<body>

<h3>Place OMR inside frame</h3>

<div id="wrap">
  <video id="video" autoplay playsinline></video>
  <div id="box"></div>
</div>

<div id="status">Searching for document inside red box…</div>

<div id="controls">
  <button id="captureBtn" onclick="capture()" disabled>Capture</button>
  <button onclick="capture(true)">Capture Anyway</button>
</div>

<canvas id="canvas" style="display:none"></canvas>

<div id="outputSection" class="output-grid hidden">
  <div class="output-card">
    1) Captured Image (Inside Red Box)
    <img id="capturedResult" alt="Captured image" />
  </div>

  <div class="output-card">
    2) Edge + CamScanner Final (Before Crop)
    <img id="pipelineResult" alt="Pipeline preview image" />
  </div>

  <div class="output-card">
    3) Cropped Image (Final Output)
    <img id="croppedResult" alt="Cropped image" />
  </div>
</div>

<script>
  const video = document.getElementById("video");
  const wrap = document.getElementById("wrap");
  const box = document.getElementById("box");
  const statusText = document.getElementById("status");
  const captureBtn = document.getElementById("captureBtn");
  const capturedResult = document.getElementById("capturedResult");
  const pipelineResult = document.getElementById("pipelineResult");
  const croppedResult = document.getElementById("croppedResult");
  const canvas = document.getElementById("canvas");
  const outputSection = document.getElementById("outputSection");

  const OMR_RATIO = 26.5 / 21.5;
  const BOX_WIDTH_RATIO = 0.84;

  let detectBusy = false;

  async function startCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { ideal: "environment" } },
        audio: false
      });
      video.srcObject = stream;
    } catch (err) {
      console.error(err);
      statusText.textContent =
        "Camera access failed. Please allow camera permission.";
    }
  }

  function updateBoundingBox() {
    const w = video.clientWidth;
    const h = video.clientHeight;
    if (!w || !h) return;

    wrap.style.height = `${h}px`;

    const maxW = h / OMR_RATIO;
    const bw = Math.min(w * BOX_WIDTH_RATIO, maxW);
    const bh = bw * OMR_RATIO;

    box.style.width = `${bw}px`;
    box.style.height = `${bh}px`;
    box.style.left = `${(w - bw) / 2}px`;
    box.style.top = `${(h - bh) / 2}px`;
  }

  video.addEventListener("loadedmetadata", () => {
    updateBoundingBox();
    setInterval(updateDetectionState, 180);
  });

  window.addEventListener("resize", updateBoundingBox);

  async function updateDetectionState() {
    if (detectBusy || !video.videoWidth || !video.videoHeight) return;
    detectBusy = true;

    try {
      const ctx = canvas.getContext("2d");
      const scale = Math.min(1, 640 / video.videoWidth);

      canvas.width = Math.floor(video.videoWidth * scale);
      canvas.height = Math.floor(video.videoHeight * scale);

      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const img = canvas.toDataURL("image/jpeg", 0.7);

      const res = await fetch("/detect", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ img })
      });

      if (!res.ok) return;

      const data = await res.json();
      box.classList.toggle("detected", data.detected);
      captureBtn.disabled = !data.can_capture;

      statusText.textContent = data.detected
        ? "Document detected inside box ✓"
        : "Searching for document inside red box…";
    } catch (err) {
      console.error("detect error", err);
    } finally {
      detectBusy = false;
    }
  }

  function capture(force = false) {
    if (!force && captureBtn.disabled) return;
    if (!video.videoWidth || !video.videoHeight) return;

    const ctx = canvas.getContext("2d");
    const scale = Math.min(1, 1280 / video.videoWidth);

    canvas.width = Math.floor(video.videoWidth * scale);
    canvas.height = Math.floor(video.videoHeight * scale);
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    const img = canvas.toDataURL("image/jpeg", 0.92);

    fetch("/process", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ img })
    })
      .then(r => {
        if (!r.ok) throw new Error("server error");
        return r.json();
      })
      .then(d => {
        capturedResult.src = d.captured_image || "";
        pipelineResult.src = d.pipeline_image || "";
        croppedResult.src = d.cropped_image || "";
        outputSection.classList.remove("hidden");
      })
      .catch(err => {
        alert("Capture failed. Try again.");
        console.error(err);
      });
  }

  startCamera();
</script>

</body>
</html>

